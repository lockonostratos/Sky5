{"version":3,"file":"\\packages\\stacktrace.js","sources":["stacktrace/stacktrace\\stacktrace.js","stacktrace/export-stacktrace.js"],"names":[],"mappings":";;;;;;;;AAAA,2D;AACA,6D;AACA,0D;AACA,gE;AACA,mE;AACA,kF;AACA,iD;AACA,4B;AACA,sC;AACA,e;AACA,mC;AACA,4D;AACA,c;AACA,wB;AACA,Y;AACA,0B;AACA,2C;AACA,K;AACA,oB;AACA,O;AACA,mF;AACA,M;AACA,sE;AACA,wF;AACA,4F;AACA,O;AACA,uC;AACA,2C;AACA,4D;AACA,yE;AACA,oE;AACA,K;;AAEA,iD;AACA,M;;AAEA,gD;AACA,W;AACA,+E;AACA,+E;AACA,W;AACA,iC;AACA,8C;AACA,yC;AACA,mC;AACA,oD;AACA,oB;AACA,sC;AACA,a;AACA,U;;AAEA,qC;AACA,iB;AACA,6B;AACA,yB;AACA,yB;AACA,a;AACA,U;;AAEA,W;AACA,0D;AACA,uE;AACA,U;AACA,+D;AACA,W;AACA,2B;AACA,4C;AACA,gC;AACA,a;;AAEA,yC;AACA,gC;AACA,a;;AAEA,sC;AACA,4B;AACA,a;;AAEA,wC;AACA,iC;AACA,a;;AAEA,oD;AACA,iE;AACA,6D;AACA,0C;AACA,oC;AACA,qD;AACA,iB;AACA,qH;AACA,8E;AACA,qD;AACA,iB;AACA,sD;AACA,a;;AAEA,uD;AACA,sD;AACA,mE;AACA,0F;AACA,iB;AACA,qD;AACA,iG;AACA,a;;AAEA,yC;AACA,2E;AACA,gE;AACA,gC;AACA,a;;AAEA,2B;AACA,U;;AAEA,W;AACA,+F;AACA,sF;AACA,U;AACA,6D;AACA,qD;AACA,uF;AACA,W;AACA,uE;AACA,wC;AACA,iD;AACA,6D;AACA,gE;AACA,kF;AACA,c;AACA,2D;AACA,U;;AAEA,W;AACA,wE;AACA,gF;AACA,iB;AACA,U;AACA,6D;AACA,wD;AACA,W;AACA,+D;AACA,iE;AACA,sD;AACA,+E;AACA,4E;AACA,a;AACA,U;;AAEA,W;AACA,0F;AACA,U;AACA,6C;AACA,0E;AACA,W;AACA,6B;AACA,mC;AACA,uE;AACA,qF;AACA,uE;AACA,sF;AACA,sD;AACA,4B;AACA,8B;AACA,U;;AAEA,W;AACA,0F;AACA,U;AACA,6C;AACA,0E;AACA,W;AACA,6B;AACA,4D;AACA,qD;AACA,kD;AACA,6B;AACA,U;;AAEA,W;AACA,sF;AACA,U;AACA,6C;AACA,0E;AACA,W;AACA,yB;AACA,0B;AACA,kD;AACA,sE;AACA,wD;AACA,4B;AACA,0B;AACA,U;;AAEA,W;AACA,2F;AACA,U;AACA,6C;AACA,0E;AACA,W;AACA,8B;AACA,yD;AACA,kE;AACA,6B;AACA,U;;AAEA,8B;AACA,qG;AACA,8D;;AAEA,kE;AACA,kD;AACA,4B;AACA,8E;AACA,2D;AACA,uH;AACA,qG;AACA,iB;AACA,a;;AAEA,0B;AACA,U;;AAEA,+B;AACA,iH;AACA,uG;AACA,0E;AACA,6C;AACA,8D;;AAEA,+D;AACA,kD;AACA,4B;AACA,8E;AACA,0E;AACA,iB;AACA,a;;AAEA,0B;AACA,U;;AAEA,W;AACA,iG;AACA,U;AACA,6C;AACA,0E;AACA,W;AACA,+B;AACA,kF;AACA,yH;AACA,4G;AACA,8D;;AAEA,kE;AACA,kD;AACA,4B;AACA,kD;AACA,wH;AACA,iB;AACA,a;;AAEA,0B;AACA,U;;AAEA,+B;AACA,6B;AACA,kF;AACA,uG;AACA,mF;AACA,2D;;AAEA,kE;AACA,kD;AACA,4B;AACA,sH;AACA,iB;AACA,a;;AAEA,0B;AACA,U;;AAEA,uC;AACA,+B;AACA,sH;AACA,8C;AACA,yD;AACA,2E;AACA,qB;AACA,+D;AACA,6B;AACA,6D;AACA,iB;AACA,qF;AACA,qB;AACA,uC;AACA,6B;AACA,uE;AACA,0B;AACA,iB;AACA,a;AACA,yB;AACA,U;;AAEA,W;AACA,2F;AACA,U;AACA,wC;AACA,iD;AACA,W;AACA,4C;AACA,4B;AACA,8C;AACA,mD;AACA,kC;AACA,wC;AACA,4C;AACA,0C;AACA,uC;AACA,6C;AACA,4E;AACA,oD;AACA,6C;AACA,iF;AACA,gC;AACA,0J;AACA,yB;AACA,4D;AACA,8C;AACA,8D;AACA,gD;AACA,4D;AACA,oD;AACA,4D;AACA,wC;AACA,4B;AACA,wC;AACA,qB;AACA,iB;AACA,a;AACA,oC;AACA,U;;AAEA,wB;;AAEA,W;AACA,qD;AACA,W;AACA,6B;AACA,iD;AACA,sB;AACA,qB;AACA,gD;AACA,yD;AACA,8D;AACA,mC;AACA,uE;AACA,4C;AACA,6B;AACA,iB;AACA,a;AACA,sB;AACA,U;;AAEA,W;AACA,0D;AACA,U;AACA,8D;AACA,W;AACA,yC;AACA,6C;AACA,4B;AACA,gD;AACA,+B;AACA,+D;AACA,+B;AACA,+D;AACA,+B;AACA,kE;AACA,iB;AACA,c;AACA,+D;AACA,qB;AACA,oD;AACA,2D;AACA,mE;AACA,mC;AACA,6B;AACA,iB;AACA,a;AACA,U;;AAEA,W;AACA,mF;AACA,qB;AACA,U;AACA,yC;AACA,oE;AACA,W;AACA,qC;AACA,2J;AACA,U;;AAEA,W;AACA,gE;AACA,U;AACA,4C;AACA,qD;AACA,W;AACA,kC;AACA,kD;AACA,6C;AACA,mE;AACA,a;AACA,yC;AACA,U;;AAEA,kD;AACA,oD;AACA,yD;AACA,sE;AACA,gE;;AAEA,0B;AACA,+C;AACA,mF;AACA,2E;AACA,wE;AACA,iG;AACA,kF;AACA,yB;AACA,qB;AACA,iB;AACA,a;AACA,yB;AACA,U;;AAEA,+D;AACA,oB;AACA,iB;AACA,yE;AACA,yB;AACA,2F;AACA,a;AACA,uB;AACA,U;;AAEA,oD;AACA,iE;AACA,wD;AACA,0D;AACA,4E;AACA,2D;AACA,qE;AACA,kG;AACA,8B;AACA,+G;AACA,+D;AACA,+D;AACA,gF;AACA,gD;AACA,yD;AACA,8C;AACA,gD;AACA,sC;AACA,sD;AACA,iB;AACA,gG;AACA,2B;AACA,uC;AACA,wD;AACA,oC;AACA,oC;AACA,qB;AACA,yD;AACA,oC;AACA,iE;AACA,oC;AACA,qB;AACA,wD;AACA,oC;AACA,oC;AACA,qB;AACA,iB;AACA,a;AACA,yB;AACA,S;AACA,M;;AAEA,2B;AACA,I;;;;;;;;;;;;;;;;;;;ACxeA,c;AACA,mC;AACA,8B;AACA,qB;AACA,kC;AACA,c;AACA,kD;AACA,sE;AACA,wC;AACA,gD;AACA,gB;AACA,S;AACA,O;AACA,K;AACA,0C;AACA,G;AACA,E","sourcesContent":["// Domain Public by Eric Wendelin http://eriwen.com/ (2008)\r\n//                  Luke Smith http://lucassmith.name/ (2008)\r\n//                  Loic Dachary <loic@dachary.org> (2008)\r\n//                  Johan Euphrosine <proppy@aminche.com> (2008)\r\n//                  Oyvind Sean Kinsey http://kinsey.no/blog (2010)\r\n//                  Victor Homyakov <victor-homyakov@users.sourceforge.net> (2010)\r\n/*global module, exports, define, ActiveXObject*/\r\n(function(global, factory) {\r\n    if (typeof exports === 'object') {\r\n        // Node\r\n        module.exports = factory();\r\n    } else if (typeof define === 'function' && define.amd) {\r\n        // AMD\r\n        define(factory);\r\n    } else {\r\n        // Browser globals\r\n        global.printStackTrace = factory();\r\n    }\r\n}(this, function() {\r\n    /**\r\n     * Main function giving a function stack trace with a forced or passed in Error\r\n     *\r\n     * @cfg {Error} e The error to create a stacktrace from (optional)\r\n     * @cfg {Boolean} guess If we should try to resolve the names of anonymous functions\r\n     * @return {Array} of Strings with functions, lines, files, and arguments where possible\r\n     */\r\n    function printStackTrace(options) {\r\n        options = options || {guess: true};\r\n        var ex = options.e || null, guess = !!options.guess;\r\n        var p = new printStackTrace.implementation(), result = p.run(ex);\r\n        return (guess) ? p.guessAnonymousFunctions(result) : result;\r\n    }\r\n\r\n    printStackTrace.implementation = function() {\r\n    };\r\n\r\n    printStackTrace.implementation.prototype = {\r\n        /**\r\n         * @param {Error} [ex] The error to create a stacktrace from (optional)\r\n         * @param {String} [mode] Forced mode (optional, mostly for unit tests)\r\n         */\r\n        run: function(ex, mode) {\r\n            ex = ex || this.createException();\r\n            mode = mode || this.mode(ex);\r\n            if (mode === 'other') {\r\n                return this.other(arguments.callee);\r\n            } else {\r\n                return this[mode](ex);\r\n            }\r\n        },\r\n\r\n        createException: function() {\r\n            try {\r\n                this.undef();\r\n            } catch (e) {\r\n                return e;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Mode could differ for different exception, e.g.\r\n         * exceptions in Chrome may or may not have arguments or stack.\r\n         *\r\n         * @return {String} mode of operation for the exception\r\n         */\r\n        mode: function(e) {\r\n            if (e['arguments'] && e.stack) {\r\n                return 'chrome';\r\n            }\r\n\r\n            if (e.stack && e.sourceURL) {\r\n                return 'safari';\r\n            }\r\n\r\n            if (e.stack && e.number) {\r\n                return 'ie';\r\n            }\r\n\r\n            if (e.stack && e.fileName) {\r\n                return 'firefox';\r\n            }\r\n\r\n            if (e.message && e['opera#sourceloc']) {\r\n                // e.message.indexOf(\"Backtrace:\") > -1 -> opera9\r\n                // 'opera#sourceloc' in e -> opera9, opera10a\r\n                // !e.stacktrace -> opera9\r\n                if (!e.stacktrace) {\r\n                    return 'opera9'; // use e.message\r\n                }\r\n                if (e.message.indexOf('\\n') > -1 && e.message.split('\\n').length > e.stacktrace.split('\\n').length) {\r\n                    // e.message may have more stack entries than e.stacktrace\r\n                    return 'opera9'; // use e.message\r\n                }\r\n                return 'opera10a'; // use e.stacktrace\r\n            }\r\n\r\n            if (e.message && e.stack && e.stacktrace) {\r\n                // e.stacktrace && e.stack -> opera10b\r\n                if (e.stacktrace.indexOf(\"called from line\") < 0) {\r\n                    return 'opera10b'; // use e.stacktrace, format differs from 'opera10a'\r\n                }\r\n                // e.stacktrace && e.stack -> opera11\r\n                return 'opera11'; // use e.stacktrace, format differs from 'opera10a', 'opera10b'\r\n            }\r\n\r\n            if (e.stack && !e.fileName) {\r\n                // Chrome 27 does not have e.arguments as earlier versions,\r\n                // but still does not have e.fileName as Firefox\r\n                return 'chrome';\r\n            }\r\n\r\n            return 'other';\r\n        },\r\n\r\n        /**\r\n         * Given a context, function name, and callback function, overwrite it so that it calls\r\n         * printStackTrace() first with a callback and then runs the rest of the body.\r\n         *\r\n         * @param {Object} context of execution (e.g. window)\r\n         * @param {String} functionName to instrument\r\n         * @param {Function} callback function to call with a stack trace on invocation\r\n         */\r\n        instrumentFunction: function(context, functionName, callback) {\r\n            context = context || window;\r\n            var original = context[functionName];\r\n            context[functionName] = function instrumented() {\r\n                callback.call(this, printStackTrace().slice(4));\r\n                return context[functionName]._instrumented.apply(this, arguments);\r\n            };\r\n            context[functionName]._instrumented = original;\r\n        },\r\n\r\n        /**\r\n         * Given a context and function name of a function that has been\r\n         * instrumented, revert the function to it's original (non-instrumented)\r\n         * state.\r\n         *\r\n         * @param {Object} context of execution (e.g. window)\r\n         * @param {String} functionName to de-instrument\r\n         */\r\n        deinstrumentFunction: function(context, functionName) {\r\n            if (context[functionName].constructor === Function &&\r\n                context[functionName]._instrumented &&\r\n                context[functionName]._instrumented.constructor === Function) {\r\n                context[functionName] = context[functionName]._instrumented;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Given an Error object, return a formatted Array based on Chrome's stack string.\r\n         *\r\n         * @param e - Error object to inspect\r\n         * @return Array<String> of function calls, files and line numbers\r\n         */\r\n        chrome: function(e) {\r\n            return (e.stack + '\\n')\r\n                .replace(/^[\\s\\S]+?\\s+at\\s+/, ' at ') // remove message\r\n                .replace(/^\\s+(at eval )?at\\s+/gm, '') // remove 'at' and indentation\r\n                .replace(/^([^\\(]+?)([\\n$])/gm, '{anonymous}() ($1)$2')\r\n                .replace(/^Object.<anonymous>\\s*\\(([^\\)]+)\\)/gm, '{anonymous}() ($1)')\r\n                .replace(/^(.+) \\((.+)\\)$/gm, '$1@$2')\r\n                .split('\\n')\r\n                .slice(0, -1);\r\n        },\r\n\r\n        /**\r\n         * Given an Error object, return a formatted Array based on Safari's stack string.\r\n         *\r\n         * @param e - Error object to inspect\r\n         * @return Array<String> of function calls, files and line numbers\r\n         */\r\n        safari: function(e) {\r\n            return e.stack.replace(/\\[native code\\]\\n/m, '')\r\n                .replace(/^(?=\\w+Error\\:).*$\\n/m, '')\r\n                .replace(/^@/gm, '{anonymous}()@')\r\n                .split('\\n');\r\n        },\r\n\r\n        /**\r\n         * Given an Error object, return a formatted Array based on IE's stack string.\r\n         *\r\n         * @param e - Error object to inspect\r\n         * @return Array<String> of function calls, files and line numbers\r\n         */\r\n        ie: function(e) {\r\n            return e.stack\r\n                .replace(/^\\s*at\\s+(.*)$/gm, '$1')\r\n                .replace(/^Anonymous function\\s+/gm, '{anonymous}() ')\r\n                .replace(/^(.+)\\s+\\((.+)\\)$/gm, '$1@$2')\r\n                .split('\\n')\r\n                .slice(1);\r\n        },\r\n\r\n        /**\r\n         * Given an Error object, return a formatted Array based on Firefox's stack string.\r\n         *\r\n         * @param e - Error object to inspect\r\n         * @return Array<String> of function calls, files and line numbers\r\n         */\r\n        firefox: function(e) {\r\n            return e.stack.replace(/(?:\\n@:0)?\\s+$/m, '')\r\n                .replace(/^(?:\\((\\S*)\\))?@/gm, '{anonymous}($1)@')\r\n                .split('\\n');\r\n        },\r\n\r\n        opera11: function(e) {\r\n            var ANON = '{anonymous}', lineRE = /^.*line (\\d+), column (\\d+)(?: in (.+))? in (\\S+):$/;\r\n            var lines = e.stacktrace.split('\\n'), result = [];\r\n\r\n            for (var i = 0, len = lines.length; i < len; i += 2) {\r\n                var match = lineRE.exec(lines[i]);\r\n                if (match) {\r\n                    var location = match[4] + ':' + match[1] + ':' + match[2];\r\n                    var fnName = match[3] || \"global code\";\r\n                    fnName = fnName.replace(/<anonymous function: (\\S+)>/, \"$1\").replace(/<anonymous function>/, ANON);\r\n                    result.push(fnName + '@' + location + ' -- ' + lines[i + 1].replace(/^\\s+/, ''));\r\n                }\r\n            }\r\n\r\n            return result;\r\n        },\r\n\r\n        opera10b: function(e) {\r\n            // \"<anonymous function: run>([arguments not available])@file://localhost/G:/js/stacktrace.js:27\\n\" +\r\n            // \"printStackTrace([arguments not available])@file://localhost/G:/js/stacktrace.js:18\\n\" +\r\n            // \"@file://localhost/G:/js/test/functional/testcase1.html:15\"\r\n            var lineRE = /^(.*)@(.+):(\\d+)$/;\r\n            var lines = e.stacktrace.split('\\n'), result = [];\r\n\r\n            for (var i = 0, len = lines.length; i < len; i++) {\r\n                var match = lineRE.exec(lines[i]);\r\n                if (match) {\r\n                    var fnName = match[1] ? (match[1] + '()') : \"global code\";\r\n                    result.push(fnName + '@' + match[2] + ':' + match[3]);\r\n                }\r\n            }\r\n\r\n            return result;\r\n        },\r\n\r\n        /**\r\n         * Given an Error object, return a formatted Array based on Opera 10's stacktrace string.\r\n         *\r\n         * @param e - Error object to inspect\r\n         * @return Array<String> of function calls, files and line numbers\r\n         */\r\n        opera10a: function(e) {\r\n            // \"  Line 27 of linked script file://localhost/G:/js/stacktrace.js\\n\"\r\n            // \"  Line 11 of inline#1 script in file://localhost/G:/js/test/functional/testcase1.html: In function foo\\n\"\r\n            var ANON = '{anonymous}', lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\r\n            var lines = e.stacktrace.split('\\n'), result = [];\r\n\r\n            for (var i = 0, len = lines.length; i < len; i += 2) {\r\n                var match = lineRE.exec(lines[i]);\r\n                if (match) {\r\n                    var fnName = match[3] || ANON;\r\n                    result.push(fnName + '()@' + match[2] + ':' + match[1] + ' -- ' + lines[i + 1].replace(/^\\s+/, ''));\r\n                }\r\n            }\r\n\r\n            return result;\r\n        },\r\n\r\n        // Opera 7.x-9.2x only!\r\n        opera9: function(e) {\r\n            // \"  Line 43 of linked script file://localhost/G:/js/stacktrace.js\\n\"\r\n            // \"  Line 7 of inline#1 script in file://localhost/G:/js/test/functional/testcase1.html\\n\"\r\n            var ANON = '{anonymous}', lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\r\n            var lines = e.message.split('\\n'), result = [];\r\n\r\n            for (var i = 2, len = lines.length; i < len; i += 2) {\r\n                var match = lineRE.exec(lines[i]);\r\n                if (match) {\r\n                    result.push(ANON + '()@' + match[2] + ':' + match[1] + ' -- ' + lines[i + 1].replace(/^\\s+/, ''));\r\n                }\r\n            }\r\n\r\n            return result;\r\n        },\r\n\r\n        // Safari 5-, IE 9-, and others\r\n        other: function(curr) {\r\n            var ANON = '{anonymous}', fnRE = /function(?:\\s+([\\w$]+))?\\s*\\(/, stack = [], fn, args, maxStackSize = 10;\r\n            var slice = Array.prototype.slice;\r\n            while (curr && stack.length < maxStackSize) {\r\n                fn = fnRE.test(curr.toString()) ? RegExp.$1 || ANON : ANON;\r\n                try {\r\n                    args = slice.call(curr['arguments'] || []);\r\n                } catch (e) {\r\n                    args = ['Cannot access arguments: ' + e];\r\n                }\r\n                stack[stack.length] = fn + '(' + this.stringifyArguments(args) + ')';\r\n                try {\r\n                    curr = curr.caller;\r\n                } catch (e) {\r\n                    stack[stack.length] = 'Cannot access caller: ' + e;\r\n                    break;\r\n                }\r\n            }\r\n            return stack;\r\n        },\r\n\r\n        /**\r\n         * Given arguments array as a String, substituting type names for non-string types.\r\n         *\r\n         * @param {Arguments,Array} args\r\n         * @return {String} stringified arguments\r\n         */\r\n        stringifyArguments: function(args) {\r\n            var result = [];\r\n            var slice = Array.prototype.slice;\r\n            for (var i = 0; i < args.length; ++i) {\r\n                var arg = args[i];\r\n                if (arg === undefined) {\r\n                    result[i] = 'undefined';\r\n                } else if (arg === null) {\r\n                    result[i] = 'null';\r\n                } else if (arg.constructor) {\r\n                    // TODO constructor comparison does not work for iframes\r\n                    if (arg.constructor === Array) {\r\n                        if (arg.length < 3) {\r\n                            result[i] = '[' + this.stringifyArguments(arg) + ']';\r\n                        } else {\r\n                            result[i] = '[' + this.stringifyArguments(slice.call(arg, 0, 1)) + '...' + this.stringifyArguments(slice.call(arg, -1)) + ']';\r\n                        }\r\n                    } else if (arg.constructor === Object) {\r\n                        result[i] = '#object';\r\n                    } else if (arg.constructor === Function) {\r\n                        result[i] = '#function';\r\n                    } else if (arg.constructor === String) {\r\n                        result[i] = '\"' + arg + '\"';\r\n                    } else if (arg.constructor === Number) {\r\n                        result[i] = arg;\r\n                    } else {\r\n                        result[i] = '?';\r\n                    }\r\n                }\r\n            }\r\n            return result.join(',');\r\n        },\r\n\r\n        sourceCache: {},\r\n\r\n        /**\r\n         * @return {String} the text from a given URL\r\n         */\r\n        ajax: function(url) {\r\n            var req = this.createXMLHTTPObject();\r\n            if (req) {\r\n                try {\r\n                    req.open('GET', url, false);\r\n                    //req.overrideMimeType('text/plain');\r\n                    //req.overrideMimeType('text/javascript');\r\n                    req.send(null);\r\n                    //return req.status == 200 ? req.responseText : '';\r\n                    return req.responseText;\r\n                } catch (e) {\r\n                }\r\n            }\r\n            return '';\r\n        },\r\n\r\n        /**\r\n         * Try XHR methods in order and store XHR factory.\r\n         *\r\n         * @return {XMLHttpRequest} XHR function or equivalent\r\n         */\r\n        createXMLHTTPObject: function() {\r\n            var xmlhttp, XMLHttpFactories = [\r\n                function() {\r\n                    return new XMLHttpRequest();\r\n                }, function() {\r\n                    return new ActiveXObject('Msxml2.XMLHTTP');\r\n                }, function() {\r\n                    return new ActiveXObject('Msxml3.XMLHTTP');\r\n                }, function() {\r\n                    return new ActiveXObject('Microsoft.XMLHTTP');\r\n                }\r\n            ];\r\n            for (var i = 0; i < XMLHttpFactories.length; i++) {\r\n                try {\r\n                    xmlhttp = XMLHttpFactories[i]();\r\n                    // Use memoization to cache the factory\r\n                    this.createXMLHTTPObject = XMLHttpFactories[i];\r\n                    return xmlhttp;\r\n                } catch (e) {\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Given a URL, check if it is in the same domain (so we can get the source\r\n         * via Ajax).\r\n         *\r\n         * @param url {String} source url\r\n         * @return {Boolean} False if we need a cross-domain request\r\n         */\r\n        isSameDomain: function(url) {\r\n            return typeof location !== \"undefined\" && url.indexOf(location.hostname) !== -1; // location may not be defined, e.g. when running from nodejs.\r\n        },\r\n\r\n        /**\r\n         * Get source code from given URL if in the same domain.\r\n         *\r\n         * @param url {String} JS source URL\r\n         * @return {Array} Array of source code lines\r\n         */\r\n        getSource: function(url) {\r\n            // TODO reuse source from script tags?\r\n            if (!(url in this.sourceCache)) {\r\n                this.sourceCache[url] = this.ajax(url).split('\\n');\r\n            }\r\n            return this.sourceCache[url];\r\n        },\r\n\r\n        guessAnonymousFunctions: function(stack) {\r\n            for (var i = 0; i < stack.length; ++i) {\r\n                var reStack = /\\{anonymous\\}\\(.*\\)@(.*)/,\r\n                    reRef = /^(.*?)(?::(\\d+))(?::(\\d+))?(?: -- .+)?$/,\r\n                    frame = stack[i], ref = reStack.exec(frame);\r\n\r\n                if (ref) {\r\n                    var m = reRef.exec(ref[1]);\r\n                    if (m) { // If falsey, we did not get any file/line information\r\n                        var file = m[1], lineno = m[2], charno = m[3] || 0;\r\n                        if (file && this.isSameDomain(file) && lineno) {\r\n                            var functionName = this.guessAnonymousFunction(file, lineno, charno);\r\n                            stack[i] = frame.replace('{anonymous}', functionName);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return stack;\r\n        },\r\n\r\n        guessAnonymousFunction: function(url, lineNo, charNo) {\r\n            var ret;\r\n            try {\r\n                ret = this.findFunctionName(this.getSource(url), lineNo);\r\n            } catch (e) {\r\n                ret = 'getSource failed with url: ' + url + ', exception: ' + e.toString();\r\n            }\r\n            return ret;\r\n        },\r\n\r\n        findFunctionName: function(source, lineNo) {\r\n            // FIXME findFunctionName fails for compressed source\r\n            // (more than one function on the same line)\r\n            // function {name}({args}) m[1]=name m[2]=args\r\n            var reFunctionDeclaration = /function\\s+([^(]*?)\\s*\\(([^)]*)\\)/;\r\n            // {name} = function ({args}) TODO args capture\r\n            // /['\"]?([0-9A-Za-z_]+)['\"]?\\s*[:=]\\s*function(?:[^(]*)/\r\n            var reFunctionExpression = /['\"]?([$_A-Za-z][$_A-Za-z0-9]*)['\"]?\\s*[:=]\\s*function\\b/;\r\n            // {name} = eval()\r\n            var reFunctionEvaluation = /['\"]?([$_A-Za-z][$_A-Za-z0-9]*)['\"]?\\s*[:=]\\s*(?:eval|new Function)\\b/;\r\n            // Walk backwards in the source lines until we find\r\n            // the line which matches one of the patterns above\r\n            var code = \"\", line, maxLines = Math.min(lineNo, 20), m, commentPos;\r\n            for (var i = 0; i < maxLines; ++i) {\r\n                // lineNo is 1-based, source[] is 0-based\r\n                line = source[lineNo - i - 1];\r\n                commentPos = line.indexOf('//');\r\n                if (commentPos >= 0) {\r\n                    line = line.substr(0, commentPos);\r\n                }\r\n                // TODO check other types of comments? Commented code may lead to false positive\r\n                if (line) {\r\n                    code = line + code;\r\n                    m = reFunctionExpression.exec(code);\r\n                    if (m && m[1]) {\r\n                        return m[1];\r\n                    }\r\n                    m = reFunctionDeclaration.exec(code);\r\n                    if (m && m[1]) {\r\n                        //return m[1] + \"(\" + (m[2] || \"\") + \")\";\r\n                        return m[1];\r\n                    }\r\n                    m = reFunctionEvaluation.exec(code);\r\n                    if (m && m[1]) {\r\n                        return m[1];\r\n                    }\r\n                }\r\n            }\r\n            return '(?)';\r\n        }\r\n    };\r\n\r\n    return printStackTrace;\r\n}));\r\n","StackTrace = {\r\n  printStackTrace: printStackTrace,\r\n  getCaller: function (skip) {\r\n    skip = skip || 2;\r\n    var lines = printStackTrace();\r\n    var i = 0;\r\n    for (; skip > 0 && i < lines.length; skip--) {\r\n      var thisFile = (lines[i].match(/@(.*\\/.+\\.(coffee|js)).*$/))[1];\r\n      for (i++; i < lines.length; i++) {\r\n        if (lines[i].indexOf(thisFile) === -1) {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    return lines[i] || '<code_minimized>';\r\n  }\r\n};\r\n"]}