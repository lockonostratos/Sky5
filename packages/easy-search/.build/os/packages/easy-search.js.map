{"version":3,"file":"\\packages\\easy-search.js","sources":["easy-search/lib\\easy-search-server.js","easy-search/lib\\easy-search-convenience.js"],"names":[],"mappings":";;;;;;;;AAAA,G;AACA,mC;AACA,6D;AACA,4B;AACA,e;AACA,E;AACA,G;;AAEA,2B;AACA,iB;;AAEA,4B;AACA,kB;AACA,mB;AACA,c;AACA,qD;AACA,iD;AACA,0C;AACA,4C;AACA,uC;AACA,4C;AACA,8C;;AAEA,+B;AACA,c;AACA,U;AACA,qD;AACA,kB;AACA,mC;AACA,U;AACA,iE;AACA,0B;AACA,+B;AACA,yB;AACA,gD;AACA,+B;AACA,kC;AACA,6D;AACA,c;AACA,c;AACA,+D;AACA,kE;AACA,c;AACA,2C;AACA,+B;AACA,e;AACA,+C;AACA,4E;AACA,a;AACA,U;AACA,8C;AACA,qD;;AAEA,O;AACA,4C;AACA,M;AACA,mE;AACA,uB;AACA,O;AACA,+B;AACA,wB;;AAEA,2C;AACA,oF;AACA,W;;AAEA,sB;AACA,K;;AAEA,O;AACA,wF;AACA,M;AACA,yE;AACA,wD;AACA,O;AACA,iB;AACA,4B;AACA,e;AACA,qD;AACA,c;AACA,mC;AACA,kC;AACA,iC;AACA,e;AACA,uD;AACA,+B;AACA,2C;AACA,iC;AACA,qC;AACA,4B;AACA,8B;AACA,yC;AACA,8B;AACA,oE;AACA,yC;AACA,qB;;AAEA,kD;AACA,gG;AACA,kE;AACA,qB;AACA,mB;AACA,c;AACA,e;AACA,wE;AACA,c;AACA,mC;AACA,sC;AACA,e;AACA,4D;AACA,yC;;AAEA,iE;AACA,2E;AACA,iB;;AAEA,0D;AACA,kD;AACA,kF;AACA,sB;AACA,oD;AACA,2E;AACA,0G;AACA,sB;AACA,4C;AACA,uC;AACA,sC;AACA,0C;AACA,gC;AACA,uD;AACA,mF;AACA,6C;AACA,2B;AACA,qB;AACA,mB;AACA,c;AACA,e;AACA,oE;AACA,c;AACA,mC;AACA,+B;AACA,e;AACA,iD;AACA,kE;;AAEA,0E;AACA,8D;;AAEA,6D;;AAEA,gD;AACA,mB;;AAEA,wB;AACA,wC;AACA,6C;AACA,kB;AACA,c;AACA,e;AACA,kE;AACA,c;AACA,mC;AACA,2C;AACA,sC;AACA,yC;AACA,2B;AACA,e;AACA,yE;AACA,4B;AACA,gC;AACA,uC;AACA,0C;AACA,iD;;AAEA,yC;AACA,2B;AACA,iB;;AAEA,2B;AACA,wD;AACA,sD;AACA,0C;AACA,kB;;AAEA,qD;AACA,yE;AACA,2B;AACA,iB;;AAEA,2D;AACA,4C;AACA,iC;AACA,kC;AACA,2C;AACA,gC;AACA,qE;AACA,2C;AACA,+B;AACA,qB;;AAEA,iD;AACA,0D;AACA,qB;;AAEA,wC;AACA,mB;;AAEA,kC;AACA,c;AACA,e;AACA,0E;AACA,c;AACA,sC;AACA,4B;AACA,e;AACA,+D;AACA,wB;AACA,yC;AACA,iD;AACA,kD;AACA,qB;AACA,kB;AACA,c;AACA,e;AACA,0E;AACA,c;AACA,sC;AACA,4B;AACA,e;AACA,gD;AACA,qC;AACA,a;AACA,U;AACA,sB;AACA,e;AACA,qC;AACA,c;AACA,0B;AACA,6B;AACA,2B;AACA,e;AACA,4D;AACA,+C;AACA,c;AACA,e;AACA,c;AACA,4D;AACA,c;AACA,mC;AACA,2C;AACA,sC;AACA,yC;AACA,2B;AACA,e;AACA,yE;AACA,2B;AACA,6B;AACA,gC;AACA,0C;;AAEA,yC;AACA,2B;AACA,iB;;AAEA,oD;;AAEA,qF;AACA,qD;;AAEA,0D;AACA,mD;AACA,mB;;AAEA,6C;AACA,8B;AACA,2E;AACA,gD;AACA,uB;AACA,iB;;AAEA,wB;AACA,uE;AACA,4C;AACA,kB;AACA,c;AACA,e;AACA,wE;AACA,c;AACA,oC;AACA,2C;AACA,sC;AACA,gC;AACA,e;AACA,+D;AACA,+B;AACA,kC;AACA,0C;AACA,kG;;AAEA,wC;AACA,qD;AACA,oC;AACA,iB;;AAEA,gD;AACA,2F;AACA,8D;AACA,iB;;AAEA,qC;AACA,qC;;AAEA,sD;AACA,oC;AACA,oB;AACA,mD;AACA,iE;AACA,0D;AACA,+D;AACA,qB;;AAEA,qD;AACA,mB;;AAEA,gC;AACA,c;AACA,e;AACA,gF;AACA,c;AACA,sC;AACA,4B;AACA,e;AACA,gD;AACA,qC;AACA,a;AACA,S;AACA,M;;AAEA,Y;AACA,W;AACA,kD;AACA,U;AACA,oC;AACA,W;AACA,yC;AACA,mD;AACA,8B;AACA,a;;AAEA,qC;;AAEA,iD;AACA,mE;AACA,U;AACA,W;AACA,iC;AACA,U;AACA,+B;AACA,kC;AACA,W;AACA,wD;AACA,gC;AACA,mC;;AAEA,iE;;AAEA,kD;AACA,uF;AACA,oC;;AAEA,oE;AACA,U;AACA,W;AACA,4B;AACA,U;AACA,4D;AACA,qE;AACA,yE;AACA,wE;AACA,W;AACA,qE;AACA,iD;;AAEA,gC;AACA,wC;AACA,mC;AACA,sD;;AAEA,iE;AACA,oG;AACA,a;AACA,Y;AACA,+C;AACA,uD;AACA,iE;AACA,uD;AACA,oB;AACA,sH;AACA,a;AACA,U;AACA,W;AACA,sC;AACA,iG;AACA,U;AACA,0C;AACA,W;AACA,gD;AACA,uC;AACA,U;AACA,W;AACA,mD;AACA,U;AACA,+B;AACA,2B;AACA,sB;AACA,W;AACA,sC;AACA,iC;AACA,U;AACA,W;AACA,6C;AACA,Y;AACA,oC;AACA,2B;AACA,U;AACA,W;AACA,uC;AACA,U;AACA,+B;AACA,2B;AACA,sB;AACA,W;AACA,yC;AACA,mC;AACA,U;AACA,W;AACA,iC;AACA,W;AACA,sC;AACA,6B;AACA,U;AACA,W;AACA,gE;AACA,sE;AACA,oD;AACA,U;AACA,uE;AACA,4E;AACA,uE;AACA,sF;AACA,W;AACA,kD;AACA,+B;AACA,4C;AACA,uD;;AAEA,qC;AACA,S;AACA,M;AACA,K;;AAEA,gB;AACA,O;AACA,0C;AACA,M;AACA,2B;AACA,mC;AACA,O;AACA,wD;AACA,4B;AACA,oC;AACA,+B;AACA,8D;AACA,K;AACA,G;;;;;;;;;;;;;;;;;;;AC1dA,yE;AACA,+B;AACA,qB;AACA,K;;AAEA,gE;AACA,4B;AACA,wB;AACA,Q;AACA,E;;AAEA,sB;AACA,+C;AACA,e;AACA,4B;;AAEA,gD;AACA,sB;AACA,S;;AAEA,uG;;AAEA,4E;AACA,K;AACA,C","sourcesContent":["/**\r\n * @title EasySearch Server Methods\r\n * @overview These are all the methods exposed on the Server.\r\n * @author Matteo De Micheli\r\n * @license MIT\r\n *\r\n */\r\n\r\nEasySearch = (function () {\r\n    'use strict';\r\n\r\n    var ElasticSearchClient,\r\n        Searchers,\r\n        indexes = {\r\n            /*\r\n            collection: Meteor.Collection (required),\r\n            field: [string] || string (required),\r\n            sort: function (searchFields),\r\n            query : function (searchFields),\r\n            limit: number (default: 10)\r\n            format: string (default: mongo),\r\n            use : string (default: 'mongo-db')\r\n\r\n            @see defaultOptions\r\n            */\r\n        },\r\n        // Default config used in EasySearch.config()\r\n        config = {\r\n            host : 'localhost:9200'\r\n        },\r\n        // Default options used in EasySearch.createSearchIndex()\r\n        defaultOptions = {\r\n            'format' : 'mongo',\r\n            'limit' : 10,\r\n            /* also useable: 'elastic-search' */\r\n            'use' : 'mongo-db',\r\n            'sort' : function () {\r\n                return Searchers[this.use].defaultSort(this);\r\n            },\r\n            /*\r\n             * When using elastic-search it's the query object,\r\n             * while using with mongo-db it's the selector object.\r\n             *\r\n             * @param {String} searchString\r\n             * @return {Object}\r\n             */\r\n            'query' : function (searchString) {\r\n                return Searchers[this.use].defaultQuery(this, searchString);\r\n            }\r\n        },\r\n        Future = Npm.require('fibers/future'),\r\n        ElasticSearch = Npm.require('elasticsearch');\r\n\r\n    /**\r\n     * Return Elastic Search indexable data.\r\n     *\r\n     * @param {Object} doc      the document to get the values from\r\n     * @return {Object}\r\n     */\r\n    function getESFields(doc) {\r\n        var newDoc = {};\r\n\r\n        _.each(doc, function (value, key) {\r\n            newDoc[key] = \"string\" === typeof value ? value : JSON.stringify(value);\r\n        });\r\n\r\n        return newDoc;\r\n    }\r\n\r\n    /**\r\n     * Searchers which contain all types which can be used to search content, until now:\r\n     *\r\n     * elastic-search: Use an elastic search server to search with (fast)\r\n     * mongo-db: Use mongodb to search (more convenient)\r\n     */\r\n    Searchers = {\r\n        'elastic-search' : {\r\n            /**\r\n             * Write a document to a specified index.\r\n             *\r\n             * @param {String} name\r\n             * @param {Object} doc\r\n             * @param {String} id\r\n             */\r\n            'writeToIndex' : function (name, doc, id) {\r\n                // add to index\r\n                ElasticSearchClient.index({\r\n                    index : name,\r\n                    type : 'default',\r\n                    id : id,\r\n                    body : doc\r\n                }, function (err, data) {\r\n                    if (err) {\r\n                        console.log('Had error adding a document!');\r\n                        console.log(err);\r\n                    }\r\n\r\n                    if (config.debug && console) {\r\n                        console.log('EasySearch: Added / Replaced document to Elastic Search:');\r\n                        console.log('EasySearch: ' + data + \"\\n\");\r\n                    }\r\n                });\r\n            },\r\n            /**\r\n             * Setup some observers on the mongo db collection provided.\r\n             *\r\n             * @param {String} name\r\n             * @param {Object} options\r\n             */\r\n            'createSearchIndex' : function (name, options) {\r\n                var searcherScope = this;\r\n\r\n                if (\"undefined\" === typeof ElasticSearchClient) {\r\n                    ElasticSearchClient = new ElasticSearch.Client(config);\r\n                }\r\n\r\n                options.collection.find().observeChanges({\r\n                    added: function (id, fields) {\r\n                        searcherScope.writeToIndex(name, getESFields(fields), id);\r\n                    },\r\n                    changed: function (id, fields) {\r\n                        // Overwrites the current document with the new doc\r\n                        searcherScope.writeToIndex(name, getESFields(options.collection.findOne(id)), id);\r\n                    },\r\n                    removed: function (id) {\r\n                        client.delete({\r\n                          index: name,\r\n                          type: 'default',\r\n                          id: id\r\n                        }, function (error, response) {\r\n                          console.log('Removed document with id ( ' +  id + ' )!');\r\n                          console.log(error);\r\n                        });\r\n                    }\r\n                });\r\n            },\r\n            /**\r\n             * Get the data out of the JSON elastic search response.\r\n             *\r\n             * @param {Object} data\r\n             * @returns {Array}\r\n             */\r\n            'extractJSONData' : function (data) {\r\n                data = _.isString(data) ? JSON.parse(data) : data;\r\n\r\n                var results = _.map(data.hits.hits, function (resultSet) {\r\n                    var mongoDbDocFake = resultSet['_source'];\r\n\r\n                    mongoDbDocFake['_id'] = resultSet['_id'];\r\n\r\n                    return resultSet['_source'];\r\n                });\r\n\r\n                return {\r\n                    'results' : results,\r\n                    'total' : data.hits.total\r\n                };\r\n            },\r\n            /**\r\n             * Perform a search with Elastic Search, using fibers.\r\n             *\r\n             * @param {String} name\r\n             * @param {String} searchString\r\n             * @param {Object} options\r\n             * @param {Function} callback\r\n             * @returns {*}\r\n             */\r\n            'search' : function (name, searchString, options, callback) {\r\n                var bodyObj,\r\n                    that = this,\r\n                    fut = new Future(),\r\n                    index = indexes[name],\r\n                    searchFields = options.field;\r\n\r\n                if (!_.isObject(index)) {\r\n                    return;\r\n                }\r\n\r\n                bodyObj = {\r\n                    \"query\" : index.query(searchString),\r\n                    \"sort\" : index.sort(searchString),\r\n                    \"size\" : options.limit\r\n                };\r\n\r\n                if (\"function\" === typeof callback) {\r\n                    ElasticSearchClient.search(name, queryObj, callback);\r\n                    return;\r\n                }\r\n\r\n                // Most likely client call, return data set\r\n                ElasticSearchClient.search({\r\n                    index : name,\r\n                    body : bodyObj\r\n                }, function (error, data) {\r\n                    if (error) {\r\n                        console.log('Had an error while searching!');\r\n                        console.log(error);\r\n                        return;\r\n                    }\r\n\r\n                    if (\"raw\" !== index.format) {\r\n                        data = that.extractJSONData(data);\r\n                    }\r\n\r\n                    fut['return'](data);\r\n                });\r\n\r\n                return fut.wait();\r\n            },\r\n            /**\r\n             * The default ES query object used for searching the results.\r\n             *\r\n             * @param {Object} options\r\n             * @return array\r\n             */\r\n            'defaultQuery' : function (options, searchString) {\r\n                return {\r\n                    \"fuzzy_like_this\" : {\r\n                        \"fields\" : options.field,\r\n                        \"like_text\" : searchString\r\n                    }\r\n                };\r\n            },\r\n            /**\r\n             * The default ES sorting method used for sorting the results.\r\n             *\r\n             * @param {Object} options\r\n             * @return array\r\n             */\r\n            'defaultSort' : function (options) {\r\n                return options.field;\r\n            }\r\n        },\r\n        'mongo-db' : {\r\n            /**\r\n             * Set up a search index.\r\n             *\r\n             * @param name\r\n             * @param options\r\n             * @returns {*}\r\n             */\r\n            'createSearchIndex' : function (name, options) {\r\n                // Don't have to setup anything\r\n            },\r\n            /**\r\n             *\r\n             * Perform a really simple search with mongo db.\r\n             *\r\n             * @param {String} name\r\n             * @param {String} searchString\r\n             * @param {Object} options\r\n             * @param {Function} callback\r\n             * @returns {*}\r\n             */\r\n            'search' : function (name, searchString, options, callback) {\r\n                var cursor,\r\n                    selector,\r\n                    that = this,\r\n                    index = indexes[name];\r\n\r\n                if (!_.isObject(index)) {\r\n                    return;\r\n                }\r\n\r\n                options.limit = options.limit || 10;\r\n\r\n                // if several, fields do an $or search, otherwise only over the field\r\n                selector = index.query(searchString);\r\n\r\n                cursor = index.collection.find(selector, {\r\n                    sort : index.sort(searchString)\r\n                });\r\n\r\n                if (_.isFunction(callback)) {\r\n                    callback({\r\n                        'results' : _.first(cursor.fetch(), options.limit),\r\n                        'total' : cursor.count()\r\n                    });\r\n                }\r\n\r\n                return {\r\n                    'results' : _.first(cursor.fetch(), options.limit),\r\n                    'total' : cursor.count()\r\n                };\r\n            },\r\n            /**\r\n             * The default mongo-db query - selector used for searching.\r\n             *\r\n             * @param {Object} index\r\n             * @param {String} searchString\r\n             * @param {Obejct} options\r\n             * @returns {Object}\r\n             */\r\n            'defaultQuery' : function (options, searchString) {\r\n                var orSelector,\r\n                    selector = {},\r\n                    field = options.field,\r\n                    stringSelector = { '$regex' : '.*' + searchString + '.*', '$options' : '-i' };\r\n\r\n                if (_.isString(field)) {\r\n                    selector[field] = stringSelector;\r\n                    return selector;\r\n                }\r\n\r\n                // Convert numbers if configured\r\n                if (options.convertNumbers && parseInt(searchString, 10) == searchString) {\r\n                    searchString = parseInt(searchString, 10);\r\n                }\r\n\r\n                // Should be an array\r\n                selector['$or'] = [];\r\n\r\n                _.each(field, function (fieldString) {\r\n                    orSelector = {};\r\n                    \r\n                    if (_.isString(searchString)) {\r\n                        orSelector[fieldString] = stringSelector;\r\n                    } else if (_.isNumber(searchString)) {\r\n                        orSelector[fieldString] = searchString;\r\n                    }\r\n\r\n                    selector['$or'].push(orSelector);\r\n                });\r\n\r\n                return selector;\r\n            },\r\n            /**\r\n             * The default mongo-db sorting method used for sorting the results.\r\n             *\r\n             * @param {Object} options\r\n             * @return array\r\n             */\r\n            'defaultSort' : function (options) {\r\n                return options.field;\r\n            }\r\n        }\r\n    };\r\n\r\n    return {\r\n        /**\r\n         * Override the config for Elastic Search.\r\n         *\r\n         * @param {object} newConfig\r\n         */\r\n        'config' : function (newConfig) {\r\n            if (\"undefined\" === typeof newConfig) {\r\n                return config;\r\n            }\r\n\r\n            check(newConfig, Object);\r\n\r\n            config = _.extend(config, newConfig);\r\n            ElasticSearchClient = new ElasticSearch.Client(config);\r\n        },\r\n        /**\r\n         * Create a search index.\r\n         *\r\n         * @param {String} name\r\n         * @param {Object} options\r\n         */\r\n        'createSearchIndex' : function (name, options) {\r\n            check(name, String);\r\n            check(options, Object);\r\n\r\n            options = _.extend(_.clone(defaultOptions), options);\r\n\r\n            check(Searchers[options.use], Object);\r\n            options.field = _.isArray(options.field) ? options.field : [options.field];\r\n            indexes[name] = options;\r\n\r\n            Searchers[options.use].createSearchIndex(name, options);\r\n        },\r\n        /**\r\n         * Perform a search.\r\n         *\r\n         * @param {String} name             the search index\r\n         * @param {String} searchString     the string to be searched\r\n         * @param {Object} options          defined with createSearchInde\r\n         * @param {Function} callback       optional callback to be used\r\n         */\r\n        'search' : function (name, searchString, options, callback) {\r\n            var searcherType = indexes[name].use;\r\n\r\n            check(name, String);\r\n            check(searchString, String);\r\n            check(options, Object);\r\n            check(callback, Match.Optional(Function));\r\n\r\n            if (\"undefined\" === typeof Searchers[searcherType]) {\r\n                throw new Meteor.Error(500, \"Couldnt search with the type: '\" + searcherType + \"'\");\r\n            }\r\n            \r\n            // If custom permission check fails\r\n            if (_.isFunction(indexes[name].permission) \r\n                    && !indexes[name].permission(searchString)) {\r\n                return { 'results' : [], 'total' : 0 };\r\n            } else {\r\n                return Searchers[searcherType].search(name, searchString, _.extend(indexes[name], options), callback);\r\n            }\r\n        },\r\n        /**\r\n         * Get the ElasticSearchClient\r\n         * @see http://www.elasticsearch.org/guide/en/elasticsearch/client/javascript-api/current\r\n         *\r\n         * @return {ElasticSearchInstance}\r\n         */\r\n        'getElasticSearchClient' : function () {\r\n            return ElasticSearchClient;\r\n        },\r\n        /**\r\n         * Retrieve a specific index configuration.\r\n         *\r\n         * @param {String} name\r\n         * @return {Object}\r\n         * @api public\r\n         */\r\n        'getIndex' : function (name) {\r\n            return indexes[name];\r\n        },\r\n        /**\r\n          * Retrieve all index configurations\r\n          */\r\n        'getIndexes' : function () {\r\n            return indexes;\r\n        },\r\n        /**\r\n         * Retrieve a specific Seacher.\r\n         *\r\n         * @param {String} name\r\n         * @return {Object}\r\n         * @api public\r\n         */\r\n        'getSearcher' : function (name) {\r\n            return Searchers[name];\r\n        },\r\n        /**\r\n         * Retrieve all Searchers\r\n         */\r\n        'getSearchers' : function () {\r\n            return Searchers;\r\n        },\r\n        /**\r\n         * Makes it possible to override or extend the different\r\n         * types of search to use with EasySearch (the \"use\" property)\r\n         * when using EasySearch.createSearchIndex()\r\n         *\r\n         * @param {String} key      Type, e.g. mongo-db, elastic-search\r\n         * @param {Object} methods  Methods to be used, only 2 are required:\r\n         *                          - createSearchIndex (name, options)\r\n         *                          - search (name, searchString, [options, callback])\r\n         */\r\n        'extendSearch' : function (key, methods) {\r\n            check(key, String);\r\n            check(methods.search, Function);\r\n            check(methods.createSearchIndex, Function);\r\n\r\n            Searchers[key] = methods;\r\n        }\r\n    };\r\n})();\r\n\r\nMeteor.methods({\r\n    /**\r\n     * Make search possible on the client.\r\n     *\r\n     * @param {String} name\r\n     * @param {String} searchString\r\n     */\r\n    easySearch: function (name, searchString, options) {\r\n        check(name, String);\r\n        check(searchString, String);\r\n        check(options, Object);\r\n        return EasySearch.search(name, searchString, options);\r\n    }\r\n});\r\n","Meteor.Collection.prototype.initEasySearch = function (fields, options) {\r\n    if (!_.isObject(options)) {\r\n        options = {};\r\n    }\r\n\r\n    EasySearch.createSearchIndex(this._name, _.extend(options, {\r\n        'collection' : this,\r\n        'field' : fields\r\n    }));\r\n};\r\n\r\nif (Meteor.isClient) {\r\n    jQuery.fn.esAutosuggestData = function () {\r\n        var id,\r\n            input = $(this);\r\n\r\n        if (input.prop(\"tagName\") !== 'INPUT') {\r\n            return [];\r\n        }\r\n\r\n        id = EasySearch.Components.generateId(input.parent().data('index'), input.parent().data('id'));\r\n\r\n        return EasySearch.ComponentVariables.get(id, 'autosuggestSelected');\r\n    }\r\n}\r\n\r\n"]}